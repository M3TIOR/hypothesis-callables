#
# TODO: make unittest stuffz
# NOTE: no more nesting tests in the library lol
#
#

# make sure we can do these tests in < python2.7 & > python3
from __future__ import division, print_function, absolute_import

from hypothesis import given
import hypothesis.errors as he
from hypothesis.internal.compat import PY3, text_type, getfullargspec

from hypothesis.strategies import *
from hypothesis_callables import *
from hypothesis_callables import 

import pytest

class TestClassStrategy(object):
	"""DOCUMENT ME!!!"""

	@given(data())
	def test_bad_child_key(self, data):
		with pytest.raises(he.InvalidArgument):
			data.draw(tuples( # core argument set container
				lists(one_of( # child names
					from_regex() # generated by known supported regex
				)),
			))

	@given(data())
	def test_bad_child_value(self, data):
		pass

	@given(data())
	def test_bad_ancestor(self, data):
		pass

	@given(data())
	def test_bad_binding_regex(self):
		pass

	@given(data())
	def test_good_instance(self):
		pass


class TestCallableStrategies(object):
	pass

class TestParameterStrategy(object):
	pass


if __name__ == "__main__":
	from hypothesis import given, settings, HealthCheck as health
	from inspect import getargspec

	#@settings(suppress_health_check=[health.too_slow])
	@given(functions())
	def test_functions(f):
		spec = getargspec(f)

		# Defined?
		print(f)
		# Check argument bindings for good shrinking
		print(spec)
		# Check execution, does it work?
		print(f())

	@given(objects())
	def test_objects(o):
		# is it registered as a class?
		print(o)
		# did we assign it's children properly?
		print(o.__dict__)

	@given(objects(), data())
	def test_unbound_methods(o, data):
		unbound_methods = data.draw(lists[UnboundMethods()])
		for method in unbound_methods:
			pass

	#test_functions()
	#test_objects()

	print("Success!")
